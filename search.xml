<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[单链表ADT的C语言（使用了部分C++特性)实现代码]]></title>
    <url>%2F2017%2F05%2F06%2FLinklist%2F</url>
    <content type="text"><![CDATA[本文的ADT使用的是 数据结构（C语言版） 严蔚敏 吴伟民著 1.C++特性：引用（&amp;） 在C语言中&amp;是取址符，但是在C++中&amp;不单单有取址这一种用法，还有做标识的作用。 最简单的用法就是：12int a=2;int &amp;ra=a;//对引用声明时必须同时初始化。 此时ra=3;等同于a=3; 然而最常用的用法是用作函数参数，也是本文代码中所使用的应用。以交换两个数值为例子。传统的C语言做法是使用指针:1234567void swap(int *a,int *b)&#123;int temp;temp=*a;*a=*b;*b=temp;&#125; 这是非常麻烦的使用方法，当我们引入了引用机制后：1234567void swap(int &amp;a,int &amp;b)&#123;int temp;temp=a;a=b;b=temp;&#125; 而调用时我们只需要用swap(x,y);即可简单的完成两个数的交换，c++自动把x,y的地址作为参数传递给swap函数。引用还有其他的应用，但这不在我们的讨论范围内。有兴趣的同学可以参阅C++ Primer（Edition 5） 2.C&amp;C++特性：typedef 在上学期的C语言课程中我们并没有学习typedef的用法，很多同学不明白是什么意思，typedef的作用是为现有类型创建同义字，为了方便我们记忆。 我也不展开说明，其实这是一个很简单而实用的用法，我就简介一下我在自己的代码中所用到的typedef的作用。 1234typedef struct Node&#123;Elemtype data;struct Node * next;&#125;Node; 这个语句可不是给一个叫Node的struct Node类型的变量声明，实际上，它首先定义了struct Node这个结构体，然后把struct Node与Node这个自定义关键字划了等号。换句话说，也就是我声明一个struct Node变量可以直接用Node而不是struct Node。即struct Node List == Node List1typedef Node * PtrtoNode; 在这个语句中我把指向一个节点的指针定义成PtrtoNode，还记得上个语句中我的定义吗？所以实际上Node * == struct Node * == PtrtoNode1typedef PtrtoNode Header; 同理，这句话把Header与PtrtoNode划了等号即Header==PtrtoNode==Node *==struct Node *。这意味着我声明一个指向结构体的指针可以不使用冗长的struct Node * List而是Header List 3.代码部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;#define Elemtype int#define Status int#define OK 1#define ERROR -1typedef struct Node&#123; struct Node * next; Elemtype data;&#125; Node;typedef Node * PtrtoNode;typedef PtrtoNode Header;int main()&#123; Header La=NULL; Header InitList(void); Status DestroyList(Header L); Status ClearList(Header L); int ListEmpty(Header L); int ListLength(Header L); Status GetElem(Header L, int i, Elemtype &amp;e); int LocateElem(Header L, Elemtype e); Status PriorElem(Header L, Elemtype cur_e, Elemtype &amp;pre_e); Status NextElem(Header L, Elemtype cur_e, Elemtype &amp;next_e); Status ListInsert(Header L, int i, Elemtype e); Status ListDelete(Header L, int i); Status ListTraverse(Header L); return 0;&#125;//初始化线性表Header InitList(void) &#123; PtrtoNode L; L = (PtrtoNode)malloc(sizeof(Node)); if (!L) exit(EXIT_FAILURE); L-&gt;next = NULL; return L;&#125;//销毁线性表Status DestroyList(Header L) &#123; if (!L)return ERROR; PtrtoNode p = L; PtrtoNode t; while (p) &#123; t = p; p = p-&gt;next; free(t); &#125; return OK;&#125;//将线性表重置为空表Status ClearList(Header L) &#123; if (!L)return ERROR; PtrtoNode p = L-&gt;next; PtrtoNode t; while (p) &#123; t = p; p = p-&gt;next; free(t); &#125; L-&gt;next = NULL; return OK;&#125;//检验是否为空表 是则返回true 否则返回falseint ListEmpty(Header L) &#123; if (!L) exit(-1); return L-&gt;next == NULL;&#125;//返回L中元素的个数int ListLength(Header L) &#123; int i=1; if (!L)exit(-1); PtrtoNode p = L-&gt;next; while (p) &#123; p = p-&gt;next; ++i; &#125; return i-1;&#125;//用e返回L中第i个元素的值Status GetElem(Header L, int i, Elemtype &amp;e) &#123; int j = 1; PtrtoNode p = L-&gt;next; while (p&amp;&amp;j &lt; i) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; i) return ERROR; e = p-&gt;data; return OK;&#125;//返回第一个与e相同的数据元素的位序int LocateElem(Header L, Elemtype e) &#123; if (!L) exit(-1); PtrtoNode p = L-&gt;next; int i=1; while (p&amp;&amp;e != p-&gt;data) &#123; p = p-&gt;next; ++i; &#125; if (!p) return -1; return i;&#125;//找出cur_e并用pre_e存储它的前驱值Status PriorElem(Header L, Elemtype cur_e, Elemtype &amp;pre_e) &#123; if (!L) exit(-1); PtrtoNode p = L; if (p-&gt;next-&gt;data == cur_e) return ERROR; else p = p-&gt;next; while (p-&gt;next&amp;&amp;p-&gt;next-&gt;data != cur_e) &#123; p = p-&gt;next; &#125; if (!p-&gt;next)return ERROR; pre_e = p-&gt;data;&#125;//找出cur_e并用next_e存储它的后继值Status NextElem(Header L, Elemtype cur_e, Elemtype &amp;next_e) &#123; if (!L) exit(-1); PtrtoNode p = L-&gt;next; while (p&amp;&amp;p-&gt;data != cur_e) &#123; p = p-&gt;next; &#125; if (!p-&gt;next) exit(ERROR); next_e = p-&gt;next-&gt;data; return OK;&#125;//在L的第i个位置前插入新的数据元素eStatus ListInsert(Header L, int i, Elemtype e) &#123; if (!L||i&lt;1) exit(-1); int j = 0; PtrtoNode p = L; PtrtoNode t = (PtrtoNode)malloc(sizeof(Node)); while (p&amp;&amp;j &lt; i - 1) &#123; p = p-&gt;next; ++j; &#125; if (!p || j &gt; i - 1) return ERROR; t-&gt;data = e; t-&gt;next = p-&gt;next; p-&gt;next = t; return OK;&#125;//删除第i个元素Status ListDelete(Header L, int i) &#123; if (!L || i &lt; 1) exit(-1); int j = 1; PtrtoNode p = L-&gt;next; PtrtoNode t = NULL; while (p&amp;&amp;j &lt; i-1) &#123; p = p-&gt;next; ++j; &#125; if (!(p-&gt;next) || j &gt; i)return ERROR; t = p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; free(t); return OK;&#125;//遍历线性表Status ListTraverse(Header L) &#123; if (!L)exit(-1); PtrtoNode p = L-&gt;next; while (p) &#123; printf(&quot;%d\n&quot;, p-&gt;data); p = p-&gt;next; &#125; return OK;&#125; 以上代码我都用驱动程序和小数据跑了一下，没有发现错误。因为我也很菜，所以代码可能不是很标准。有问题请您务必指正。E-Mail：gennameless@gmail.com]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>